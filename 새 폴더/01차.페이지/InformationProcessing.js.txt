// ========================== 전역 변수 ==========================
let categories = [];
let currentCategoryIndex = null;
let currentProblemIndex = 0;
let showAnswer = false;

// ========================== 초기화 및 데이터 로드 ==========================
document.addEventListener('DOMContentLoaded', () => {
    loadData();
});

async function loadData() {
    try {
        const response = await fetch('InformationProcessing.json');
        const data = await response.json();
        
        categories = data.categories;
        
        renderAccordion();
        
    } catch (error) {
        console.error('JSON 파일 로드 실패:', error);
        alert('문제 데이터를 불러오는데 실패했습니다.');
    }
}

// ========================== 아코디언 렌더링 ==========================
function renderAccordion() {
    const container = document.getElementById('accordionContainer');
    container.innerHTML = '';
    
    categories.forEach((category, index) => {
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        accordionItem.id = `accordion-${index}`;
        
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.onclick = () => toggleAccordion(index);
        
        header.innerHTML = `
            <div class="accordion-title">
                <span class="accordion-icon">${category.icon}</span>
                <span>${category.name}</span>
            </div>
            <span class="accordion-arrow">▼</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'accordion-content';
        content.id = `content-${index}`;
        
        if (category.problems && category.problems.length > 0) {
            content.innerHTML = createProblemContent(index);
        } else {
            content.innerHTML = `
                <div class="empty-message">
                    <div class="empty-message-icon">📝</div>
                    <div class="empty-message-text">준비 중인 카테고리입니다</div>
                </div>
            `;
        }
        
        accordionItem.appendChild(header);
        accordionItem.appendChild(content);
        container.appendChild(accordionItem);
    });
}

function toggleAccordion(index) {
    const item = document.getElementById(`accordion-${index}`);
    const wasActive = item.classList.contains('active');
    
    document.querySelectorAll('.accordion-item').forEach(el => {
        el.classList.remove('active');
    });
    
    if (!wasActive) {
        item.classList.add('active');
        currentCategoryIndex = index;
        currentProblemIndex = 0;
        
        if (categories[index].problems && categories[index].problems.length > 0) {
            updateProblemDisplay(index);
        }
    } else {
        currentCategoryIndex = null;
    }
}

// ========================== 문제 화면 구성 ==========================
function createProblemContent(categoryIndex) {
    return `
        <div class="problem-container" id="problem-container-${categoryIndex}">
            <div class="problem-info">
                <div class="info-left">
                    <span class="badge badge-primary" id="problemNumber-${categoryIndex}">문제 1 / ${categories[categoryIndex].problems.length}</span>
                    <span class="badge badge-secondary" id="examInfo-${categoryIndex}">시험</span>
                    <span class="badge badge-category" id="categoryBadge-${categoryIndex}" style="display: none;"></span>
                </div>
                <span class="badge badge-success">${categories[categoryIndex].name}</span>
            </div>

            <div class="problem-grid" id="problemGrid-${categoryIndex}"></div>

            <div class="problem-box">
                <h3>문제</h3>
                <p id="questionText-${categoryIndex}" class="question-text"></p>
            </div>

            <div class="answer-input-box">
                <label for="userAnswer-${categoryIndex}">답안 입력</label>
                <textarea 
                    id="userAnswer-${categoryIndex}" 
                    placeholder="답을 입력하세요..."
                    rows="3"
                ></textarea>
            </div>

            <div class="difficulty-selector" id="difficultySelector-${categoryIndex}" style="display: none;">
                <label for="difficulty-${categoryIndex}">난이도 선택:</label>
                <select id="difficulty-${categoryIndex}" class="difficulty-dropdown">
                    <option value="1">📊 간단 (레벨 1)</option>
                    <option value="2">🔥 복잡 (레벨 2)</option>
                </select>
            </div>

            <!-- ⬇️⬇️⬇️ 여기에 추가! ⬇️⬇️⬇️ -->
            <div class="category-selector" id="categorySelector-${categoryIndex}" style="display: none;">
                <label for="cCategory-${categoryIndex}">문제 유형 선택:</label>
                <select id="cCategory-${categoryIndex}" class="category-dropdown">
                    <optgroup label="📊 정렬 알고리즘">
                        <option value="selectionSort">선택정렬</option>
                        <option value="bubbleSort">버블정렬</option>
                        <option value="insertionSort">삽입정렬</option>
                    </optgroup>
                    <optgroup label="⚙️ 연산">
                        <option value="logicalOp">논리연산</option>
                        <option value="bitOp">비트연산</option>
                    </optgroup>
                    <optgroup label="🔀 조건문">
                        <option value="ifStmt">if문</option>
                        <option value="switchStmt">switch문</option>
                    </optgroup>
                    <optgroup label="🔁 반복문">
                        <option value="forLoop">for문</option>
                        <option value="whileLoop">while문</option>
                        <option value="doWhile">do-while문</option>
                        <option value="breakContinue">break/continue</option>
                        <option value="nestedLoop">다중for문</option>
                    </optgroup>
                    <optgroup label="📦 배열 & 포인터">
                        <option value="array">배열</option>
                        <option value="pointer">포인터</option>
                        <option value="arrayPointer">배열과포인터</option>
                        <option value="array2d">2차원배열</option>
                        <option value="pointerArray">포인터배열</option>
                    </optgroup>
                    <optgroup label="🏗️ 구조체">
                        <option value="struct">구조체</option>
                        <option value="arrayPointerStruct">배열포인터</option>
                    </optgroup>
                    <optgroup label="📞 함수">
                        <option value="function">기본함수</option>
                        <option value="functionLoop">함수와반복문</option>
                        <option value="functionAddress">함수에주소전달</option>
                        <option value="functionScope">함수와변수유효범위</option>
                        <option value="functionReturnAddress">함수가주소리턴</option>
                        <option value="staticVar">static변수</option>
                        <option value="recursion">재귀함수</option>
                        <option value="multiRecursion">중복재귀함수</option>
                    </optgroup>
                    <optgroup label="📌 기타">
                        <option value="printfOrder">printf출력순서</option>
                    </optgroup>
                </select>
            </div>
            <div class="algorithm-selector" id="algorithmSelector-${categoryIndex}" style="display: none;">
                <label for="pageAlgorithm-${categoryIndex}">알고리즘 선택:</label>
                <select id="pageAlgorithm-${categoryIndex}" class="algorithm-dropdown">
                    <option value="FIFO">📥 FIFO (First In First Out)</option>
                    <option value="LRU">🕒 LRU (Least Recently Used)</option>
                    <option value="LFU">📊 LFU (Least Frequently Used)</option>
                </select>
            </div>            
            <button onclick="generateRandomProblem(${categoryIndex})" class="btn btn-random">
                🎲 새 문제 만들기
            </button>

            <button onclick="toggleAnswer(${categoryIndex})" class="btn btn-answer" id="toggleAnswerBtn-${categoryIndex}">
                정답 확인
            </button>

            <div id="answerBox-${categoryIndex}" class="answer-box hidden">
                <h3>정답</h3>
                <p id="answerText-${categoryIndex}" class="answer-text"></p>
            </div>

            <div class="navigation">
                <button onclick="prevProblem(${categoryIndex})" class="btn btn-nav" id="prevBtn-${categoryIndex}">이전 문제</button>
                <button onclick="nextProblem(${categoryIndex})" class="btn btn-nav btn-primary" id="nextBtn-${categoryIndex}">다음 문제</button>
            </div>
        </div>
    `;
}

// ========================== 문제 표시 및 네비게이션 ==========================
function updateProblemDisplay(categoryIndex) {
    const category = categories[categoryIndex];
    const problem = category.problems[currentProblemIndex];
    
    document.getElementById(`problemNumber-${categoryIndex}`).textContent = 
        `문제 ${currentProblemIndex + 1} / ${category.problems.length}`;
    document.getElementById(`examInfo-${categoryIndex}`).textContent = problem.exam;
    // 카테고리 뱃지 추가
    const categoryBadge = document.getElementById(`categoryBadge-${categoryIndex}`);
    if (categoryBadge && problem.category) {
        categoryBadge.textContent = problem.category;
        categoryBadge.style.display = 'inline-block';
    } else if (categoryBadge) {
        categoryBadge.style.display = 'none';
    }
    // 문제 텍스트 표시
    const questionElement = document.getElementById(`questionText-${categoryIndex}`);
    // \\n을 실제 줄바꿈으로 변환
    questionElement.textContent = problem.question.replace(/\\n/g, '\n');

    // Python 코드가 있으면 스타일 추가
    if (category.id === 'python' && (problem.question.includes('def ') || problem.question.includes('print(') || problem.question.includes('for ') || problem.question.includes('='))) {
        questionElement.classList.add('has-python-code');
    }// Java 코드가 있으면 스타일 추가
    else if (category.id === 'java' && (problem.question.includes('public class') || problem.question.includes('class ') || problem.question.includes('System.out'))) {
        questionElement.classList.add('has-java-code');
        questionElement.classList.remove('has-python-code');
        questionElement.classList.remove('has-c-code');
    } 
    // C언어 코드가 있으면 스타일 추가
    else if (category.id === 'c' && (problem.question.includes('#include') || problem.question.includes('int main()') || problem.question.includes('printf('))) {
        questionElement.classList.add('has-c-code');
        questionElement.classList.remove('has-python-code');
        questionElement.classList.remove('has-java-code');
    }
    document.getElementById(`answerText-${categoryIndex}`).textContent = problem.answer;
    
    document.getElementById(`userAnswer-${categoryIndex}`).value = '';
    
    hideAnswerBox(categoryIndex);
    updateNavigationButtons(categoryIndex);
    createProblemGrid(categoryIndex);
    
    // 난이도 선택 표시/숨김 (Python만 표시)
    const difficultySelector = document.getElementById(`difficultySelector-${categoryIndex}`);
    if (difficultySelector) {
        if (category.id === 'python') {
            difficultySelector.style.display = 'block';
        } else {
            difficultySelector.style.display = 'none';
        }
    }
    const categorySelector = document.getElementById(`categorySelector-${categoryIndex}`);
    if (categorySelector) {
        if (category.id === 'c' && currentProblemIndex === 28) {
            categorySelector.style.display = 'block';
        } else {
            categorySelector.style.display = 'none';
        }
    }
    const answerInputBox = document.querySelector(`#problem-container-${categoryIndex} .answer-input-box`);
    
    if (category.id === 'page' && currentProblemIndex === 3 && problem.pages) {
        // 페이지 교체 4번 문제: 동적 테이블 생성
        answerInputBox.innerHTML = createPageAnswerForm(categoryIndex, problem);
    } else {
        // 기존 textarea 복원
        answerInputBox.innerHTML = `
            <label for="userAnswer-${categoryIndex}">답안 입력</label>
            <textarea 
                id="userAnswer-${categoryIndex}" 
                placeholder="답을 입력하세요..."
                rows="3"
            ></textarea>
        `;
    }
}

// ========================== 페이지 교체 답안 입력 폼 ==========================
function createPageAnswerForm(categoryIndex, problem) {
    const pages = problem.pages;
    const frameCount = problem.frameCount;
    
    let html = '<label>답안 입력 (표를 채워주세요)</label>';
    html += '<div class="page-answer-form">';
    html += '<table class="page-input-table">';
    
    // 헤더
    html += '<thead><tr>';
    html += '<th class="label-col">구분</th>';
    for (let i = 0; i < pages.length; i++) {
        html += `<th>${i + 1}</th>`;
    }
    html += '</tr></thead>';
    
    // 바디
    html += '<tbody>';
    
    // 참조 행 (읽기 전용)
    html += '<tr class="reference-row">';
    html += '<td class="label-col">참조</td>';
    for (let page of pages) {
        html += `<td class="reference-cell">${page}</td>`;
    }
    html += '</tr>';
    
    // 프레임 행들 (입력)
    for (let f = 0; f < frameCount; f++) {
        html += `<tr class="frame-input-row">`;
        html += `<td class="label-col">프레임${f + 1}</td>`;
        for (let i = 0; i < pages.length; i++) {
            html += `<td><input type="text" class="frame-input" data-frame="${f}" data-step="${i}" maxlength="2" /></td>`;
        }
        html += '</tr>';
    }
    
    // 부재 행 (라디오 버튼)
    html += '<tr class="fault-input-row">';
    html += '<td class="label-col">부재</td>';
    for (let i = 0; i < pages.length; i++) {
        html += `<td class="fault-cell">
            <label class="radio-label">
                <input type="radio" name="fault-${i}" value="O" /> O
            </label>
            <label class="radio-label">
                <input type="radio" name="fault-${i}" value="X" /> X
            </label>
        </td>`;
    }
    html += '</tr>';
    
    html += '</tbody>';
    html += '</table>';
    html += '</div>';
    
    // 정답 제출 버튼
    html += `<button onclick="submitPageAnswer(${categoryIndex})" class="btn btn-submit">✅ 정답 제출</button>`;
    
    return html;
}

function submitPageAnswer(categoryIndex) {
    const category = categories[categoryIndex];
    const problem = category.problems[currentProblemIndex];
    const correctAnswer = problem.correctAnswer;
    const pages = problem.pages;
    const frameCount = problem.frameCount;
    
    // 사용자 답안 수집
    let isAllCorrect = true;
    let wrongCount = 0;
    
    // 프레임 검사
    for (let f = 0; f < frameCount; f++) {
        for (let i = 0; i < pages.length; i++) {
            const input = document.querySelector(`input.frame-input[data-frame="${f}"][data-step="${i}"]`);
            const userValue = input.value.trim();
            const correctValue = correctAnswer.history[i].frames[f];
            const correctStr = (correctValue !== undefined && correctValue !== null) ? correctValue.toString() : '';
            
            const cell = input.parentElement;
            
            if (userValue === correctStr || (userValue === '' && correctStr === '') || (userValue === '-' && correctStr === '')) {
                cell.classList.remove('wrong-answer');
                cell.classList.add('correct-answer');
            } else {
                cell.classList.remove('correct-answer');
                cell.classList.add('wrong-answer');
                isAllCorrect = false;
                wrongCount++;
            }
        }
    }
    
    // 부재 검사
    for (let i = 0; i < pages.length; i++) {
        const selectedRadio = document.querySelector(`input[name="fault-${i}"]:checked`);
        const userFault = selectedRadio ? selectedRadio.value : null;
        const correctFault = correctAnswer.history[i].fault ? 'O' : 'X';
        
        const cell = selectedRadio ? selectedRadio.closest('td') : document.querySelector(`input[name="fault-${i}"]`).closest('td');
        
        if (userFault === correctFault) {
            cell.classList.remove('wrong-answer');
            cell.classList.add('correct-answer');
        } else {
            cell.classList.remove('correct-answer');
            cell.classList.add('wrong-answer');
            isAllCorrect = false;
            wrongCount++;
        }
    }
    
    // 결과 알림
    if (isAllCorrect) {
        alert('🎉 정답입니다! 모든 칸이 정확합니다!');
    } else {
        alert(`❌ 틀렸습니다. ${wrongCount}개의 오답이 있습니다.\n틀린 부분은 빨간색으로 표시되었습니다.`);
    }
}



function createProblemGrid(categoryIndex) {
    const grid = document.getElementById(`problemGrid-${categoryIndex}`);
    const category = categories[categoryIndex];
    
    grid.innerHTML = '';
    
    category.problems.forEach((_, index) => {
        const btn = document.createElement('button');
        btn.className = 'problem-number-btn';
        if (index === currentProblemIndex) {
            btn.classList.add('active');
        }
        btn.textContent = index + 1;
        btn.onclick = () => goToProblem(categoryIndex, index);
        grid.appendChild(btn);
    });
}

function goToProblem(categoryIndex, problemIndex) {
    currentProblemIndex = problemIndex;
    updateProblemDisplay(categoryIndex);
}

function nextProblem(categoryIndex) {
    const category = categories[categoryIndex];
    if (currentProblemIndex < category.problems.length - 1) {
        currentProblemIndex++;
        updateProblemDisplay(categoryIndex);
    }
}

function prevProblem(categoryIndex) {
    if (currentProblemIndex > 0) {
        currentProblemIndex--;
        updateProblemDisplay(categoryIndex);
    }
}

function updateNavigationButtons(categoryIndex) {
    const category = categories[categoryIndex];
    document.getElementById(`prevBtn-${categoryIndex}`).disabled = currentProblemIndex === 0;
    document.getElementById(`nextBtn-${categoryIndex}`).disabled = currentProblemIndex === category.problems.length - 1;
}

// ========================== 정답 표시 ==========================
function toggleAnswer(categoryIndex) {
    const answerBox = document.getElementById(`answerBox-${categoryIndex}`);
    const toggleBtn = document.getElementById(`toggleAnswerBtn-${categoryIndex}`);
    const answerText = document.getElementById(`answerText-${categoryIndex}`);
    const category = categories[categoryIndex];
    
    if (answerBox.classList.contains('hidden')) {
        // 페이지 교체 4번 문제면 HTML 렌더링
        if (category.id === 'page' && currentProblemIndex === 3) {
            answerText.innerHTML = category.problems[currentProblemIndex].answer;
        } else {
            answerText.textContent = category.problems[currentProblemIndex].answer;
        }
        
        answerBox.classList.remove('hidden');
        toggleBtn.textContent = '정답 숨기기';
    } else {
        hideAnswerBox(categoryIndex);
    }
}

function hideAnswerBox(categoryIndex) {
    const answerBox = document.getElementById(`answerBox-${categoryIndex}`);
    const toggleBtn = document.getElementById(`toggleAnswerBtn-${categoryIndex}`);
    
    answerBox.classList.add('hidden');
    toggleBtn.textContent = '정답 확인';
}

// ========================== 랜덤 문제 생성 메인 ==========================
function generateRandomProblem(categoryIndex) {
    const category = categories[categoryIndex];
    const problem = category.problems[currentProblemIndex];
    
    if (category.id === 'subnet') {
        if (problem.id === 1) {
            generateRandomIPAllocationProblem(categoryIndex);
        } else if (problem.id === 2) {
            generateRandomFLSMProblem(categoryIndex);
        } else if (problem.id === 3) {
            generateRandomSubnetProblem(categoryIndex);
        }
    } else if (category.id === 'page') {
        if (currentProblemIndex === 3) {  // 4번 문제
            const algorithmSelect = document.getElementById(`pageAlgorithm-${categoryIndex}`);
            const selectedAlgorithm = algorithmSelect ? algorithmSelect.value : 'FIFO';
            generateCategorizedPageProblem(categoryIndex, selectedAlgorithm);
        } else {  // 1~3번 문제
            generateRandomPageReplacementProblem(categoryIndex);  // 기존 방식 그대로
        }
    } else if (category.id === 'schedule') {
        generateRandomSchedulingProblem(categoryIndex);
    } else if (category.id === 'base') {
        generateRandomBaseConversionProblem(categoryIndex);
    } else if (category.id === 'python') {
        // 난이도 선택 가져오기
        const difficultySelect = document.getElementById(`difficulty-${categoryIndex}`);
        const difficulty = difficultySelect ? parseInt(difficultySelect.value) : 1;
        generateRandomPythonProblem(categoryIndex, difficulty);
    } else if (category.id === 'java') { 
        generateRandomJavaProblem(categoryIndex);
    } else if (category.id === 'c') {
        if (currentProblemIndex === 28) {  // 29번 문제
            const categorySelect = document.getElementById(`cCategory-${categoryIndex}`);
            const selectedCategory = categorySelect ? categorySelect.value : 'forLoop';
            generateCategorizedCProblem(categoryIndex, selectedCategory);
        } else {  // 1~28번 문제
            generateRandomCProblem(categoryIndex);  // 기존 방식 그대로
        }
    }
    
    updateProblemDisplay(categoryIndex);
}

// ========================== 서브넷/네트워크 알고리즘 시작 ==========================
function generateRandomSubnetProblem(categoryIndex) {
    const octets = [
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256)
    ];
    
    const subnetMasks = [128, 192, 224, 240, 248, 252];
    const subnetMask = subnetMasks[Math.floor(Math.random() * subnetMasks.length)];
    
    const ipAddress = `${octets[0]}.${octets[1]}.${octets[2]}.${octets[3]}`;
    const maskString = `255.255.255.${subnetMask}`;
    
    const networkAddress = octets[3] & subnetMask;
    const hostBits = 8 - Math.log2(256 - subnetMask);
    const totalHosts = Math.pow(2, hostBits) - 2;
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `IP 주소가 ${ipAddress}이고 서브넷마스크 ${maskString}일 때 아래의 답을 작성하시오.\n(1) 괄호안에 들어갈 네트워크 주소 : ${octets[0]}.${octets[1]}.${octets[2]}.( )\n(2) 해당 네트워크 주소와 브로드캐스트 주소를 제외한 호스트 개수`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = 
        `(1) ${networkAddress}\n(2) ${totalHosts}`;
}

function generateRandomFLSMProblem(categoryIndex) {
    const octets = [
        192,
        168,
        Math.floor(Math.random() * 256),
        0
    ];
    
    const cidrs = [20, 22, 24];
    const cidr = cidrs[Math.floor(Math.random() * cidrs.length)];
    
    const divisions = [2, 4, 8];
    const divisionCount = divisions[Math.floor(Math.random() * divisions.length)];
    
    const whichNetwork = Math.floor(Math.random() * divisionCount) + 1;
    
    const newCidr = cidr + Math.log2(divisionCount);
    const hostBits = 32 - newCidr;
    const subnetSize = Math.pow(2, hostBits);
    
    const networkBase = `${octets[0]}.${octets[1]}.${octets[2]}.${octets[3]}`;
    
    let broadcastIP;
    if (cidr === 24) {
        const broadcastLastOctet = (whichNetwork * subnetSize) - 1;
        broadcastIP = `${octets[0]}.${octets[1]}.${octets[2]}.${broadcastLastOctet}`;
    } else if (cidr === 22) {
        const totalBroadcast = (whichNetwork * subnetSize) - 1;
        const thirdOctet = Math.floor(totalBroadcast / 256);
        const fourthOctet = totalBroadcast % 256;
        broadcastIP = `${octets[0]}.${octets[1]}.${thirdOctet}.${fourthOctet}`;
    } else {
        const totalBroadcast = (whichNetwork * subnetSize) - 1;
        const thirdOctet = Math.floor(totalBroadcast / 256);
        const fourthOctet = totalBroadcast % 256;
        broadcastIP = `${octets[0]}.${octets[1]}.${thirdOctet}.${fourthOctet}`;
    }
    
    const networkNames = ['첫', '두', '세', '네', '다섯', '여섯', '일곱', '여덟'];
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `${networkBase}/${cidr}인 네트워크를 FLSM ${divisionCount}개로 분할하였다. ${networkNames[whichNetwork - 1]}번째 네트워크 브로드캐스트 IP를 10진수로 변환한 값을 작성하시오.`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = broadcastIP;
}

function generateRandomIPAllocationProblem(categoryIndex) {
    const baseOctet1 = 192;
    const baseOctet2 = 168;
    const baseOctet3 = Math.floor(Math.random() * 50) + 1;
    
    const ip1 = `${baseOctet1}.${baseOctet2}.${baseOctet3}.${Math.floor(Math.random() * 200) + 1}/24`;
    const ip3 = `${baseOctet1 - Math.floor(Math.random() * 60)}.${200 + Math.floor(Math.random() * 55)}.${Math.floor(Math.random() * 50)}.${Math.floor(Math.random() * 200) + 1}/22`;
    const ip6 = `${baseOctet1}.${baseOctet2}.${baseOctet3 + 1}.${Math.floor(Math.random() * 200) + 1}/24`;
    
    const choice1 = `${baseOctet1}.${baseOctet2}.${baseOctet3}.0`;
    const choice2 = `${baseOctet1}.${baseOctet2}.${baseOctet3}.${Math.floor(Math.random() * 200) + 50}`;
    const choice3 = `${baseOctet1}.${baseOctet2}.${baseOctet3 + 1}.0`;
    const choice4 = `${baseOctet1}.${baseOctet2}.${baseOctet3 + 1}.${Math.floor(Math.random() * 200) + 200}`;
    
    const ip3Parts = ip3.split('.');
    const ip3Base = `${ip3Parts[0]}.${ip3Parts[1]}.${parseInt(ip3Parts[2]) & 0xFC}.0`;
    const choice5 = ip3Base;
    const choice6 = `${ip3Parts[0]}.${ip3Parts[1]}.${(parseInt(ip3Parts[2]) & 0xFC) + 3}.${Math.floor(Math.random() * 200) + 200}`;
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `네트워크에서 라우터를 통한 할당 가능한 2번, 4번, 5번의 IP를 작성하시오.\n1) ${ip1}\n3) ${ip3}\n6) ${ip6}\n\n보기\n${choice1}, ${choice2}, ${choice3}, ${choice4}, ${choice5}, ${choice6}`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = 
        `2) ${choice2}\n4) ${choice4}\n5) ${choice6}`;
}
// ========================== 서브넷/네트워크 알고리즘 끝 ==========================

// ========================== 페이지 교체 알고리즘 시작 ==========================
function generateRandomPageReplacementProblem(categoryIndex) {
    const algorithms = ['FIFO', 'LRU', 'LFU'];
    const algorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
    
    const frameCount = 3 + Math.floor(Math.random() * 2);
    
    const pageCount = 12 + Math.floor(Math.random() * 9);
    const pages = [];
    for (let i = 0; i < pageCount; i++) {
        pages.push(Math.floor(Math.random() * 10));
    }
    
    const pageString = pages.join(' ');
    
    let faults = 0;
    if (algorithm === 'FIFO') {
        faults = simulateFIFO(pages, frameCount);
    } else if (algorithm === 'LRU') {
        faults = simulateLRU(pages, frameCount);
    } else if (algorithm === 'LFU') {
        faults = simulateLFU(pages, frameCount);
    }
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `${algorithm} 페이지 교체 알고리즘에 따른 페이지 부재 횟수를 작성하시오. (프레임 ${frameCount}개)\n\n페이지 참조 순서: ${pageString}`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = `${faults}`;
}

function simulateFIFO(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    
    for (let page of pages) {
        if (!frames.includes(page)) {
            pageFaults++;
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                frames.shift();
                frames.push(page);
            }
        }
    }
    
    return pageFaults;
}

function simulateLRU(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    
    for (let i = 0; i < pages.length; i++) {
        const page = pages[i];
        
        if (!frames.includes(page)) {
            pageFaults++;
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lruIndex = 0;
                let minLastUsed = i;
                
                for (let j = 0; j < frames.length; j++) {
                    let lastUsed = -1;
                    for (let k = i - 1; k >= 0; k--) {
                        if (pages[k] === frames[j]) {
                            lastUsed = k;
                            break;
                        }
                    }
                    
                    if (lastUsed < minLastUsed) {
                        minLastUsed = lastUsed;
                        lruIndex = j;
                    }
                }
                
                frames[lruIndex] = page;
            }
        }
    }
    
    return pageFaults;
}

function simulateLFU(pages, frameCount) {
    const frames = [];
    const frequency = {};
    let pageFaults = 0;
    
    for (let page of pages) {
        frequency[page] = (frequency[page] || 0) + 1;
        
        if (!frames.includes(page)) {
            pageFaults++;
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lfuIndex = 0;
                let minFreq = frequency[frames[0]];
                
                for (let j = 1; j < frames.length; j++) {
                    if (frequency[frames[j]] < minFreq) {
                        minFreq = frequency[frames[j]];
                        lfuIndex = j;
                    }
                }
                
                frames[lfuIndex] = page;
            }
        }
    }
    
    return pageFaults;
}
// ========================== 페이지 교체 세분화 알고리즘 시작 ==========================
function generateCategorizedPageProblem(categoryIndex, algorithm) {
    const frameCount = 3 + Math.floor(Math.random() * 2);
    
    const pageCount = 12 + Math.floor(Math.random() * 9);
    const pages = [];
    for (let i = 0; i < pageCount; i++) {
        pages.push(Math.floor(Math.random() * 10));
    }
    
    const pageString = pages.join(' ');
    
    let result;
    
    if (algorithm === 'FIFO') {
        result = simulateFIFODetailed(pages, frameCount);
    } else if (algorithm === 'LRU') {
        result = simulateLRUDetailed(pages, frameCount);
    } else if (algorithm === 'LFU') {
        result = simulateLFUDetailed(pages, frameCount);
    }
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `${algorithm} 페이지 교체 알고리즘에 따른 페이지 부재 횟수와 프레임 최종 상태를 작성하시오. (프레임 ${frameCount}개)\n\n페이지 참조 순서: ${pageString}`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = 
        formatPageReplacementAnswer(result, pages, frameCount);
    
    // 답안 입력 폼 생성 (정답 데이터 저장)
    categories[categoryIndex].problems[currentProblemIndex].correctAnswer = result;
    categories[categoryIndex].problems[currentProblemIndex].pages = pages;
    categories[categoryIndex].problems[currentProblemIndex].frameCount = frameCount;
}

function formatPageReplacementAnswer(result, pages, frameCount) {
    let html = '<div class="page-algorithm-result">';
    
    // 테이블 시작
    html += '<table class="page-table">';
    
    // 헤더
    html += '<thead><tr>';
    html += '<th class="label-col">구분</th>';
    for (let i = 0; i < pages.length; i++) {
        html += `<th>${i + 1}</th>`;
    }
    html += '</tr></thead>';
    
    // 바디
    html += '<tbody>';
    
    // 참조 행
    html += '<tr class="reference-row">';
    html += '<td class="label-col">참조</td>';
    for (let page of pages) {
        html += `<td class="reference-cell">${page}</td>`;
    }
    html += '</tr>';
    
    // 프레임 행들
    for (let f = 0; f < frameCount; f++) {
        html += `<tr class="frame-row">`;
        html += `<td class="label-col">프레임${f + 1}</td>`;
        for (let step of result.history) {
            const frameValue = step.frames[f];
            if (frameValue !== undefined && frameValue !== null) {
                html += `<td class="frame-cell">${frameValue}</td>`;
            } else {
                html += `<td class="empty-cell">-</td>`;
            }
        }
        html += '</tr>';
    }
    
    // 부재 행
    html += '<tr class="fault-row">';
    html += '<td class="label-col">부재</td>';
    for (let step of result.history) {
        if (step.fault) {
            html += `<td class="fault-yes">O</td>`;
        } else {
            html += `<td class="fault-no">X</td>`;
        }
    }
    html += '</tr>';
    
    // Out 행
    html += '<tr class="out-row">';
    html += '<td class="label-col">Out</td>';
    for (let step of result.history) {
        if (step.out !== null && step.out !== undefined) {
            html += `<td class="out-cell">${step.out}</td>`;
        } else {
            html += `<td class="empty-cell">-</td>`;
        }
    }
    html += '</tr>';
    
    html += '</tbody>';
    html += '</table>';
    
    // 요약
    html += '<div class="result-summary">';
    html += `<div class="summary-item"><span class="summary-label">📊 페이지 부재 횟수:</span> <span class="summary-value">${result.faults}</span></div>`;
    html += `<div class="summary-item"><span class="summary-label">📦 프레임 최종 상태:</span> <span class="summary-value">[${result.finalFrames.join(', ')}]</span></div>`;
    html += '</div>';
    
    html += '</div>';
    
    return html;
}

function simulateFIFODetailed(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    const history = [];
    
    for (let page of pages) {
        let fault = false;
        let out = null;
        
        if (!frames.includes(page)) {
            pageFaults++;
            fault = true;
            
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                out = frames.shift();
                frames.push(page);
            }
        }
        
        history.push({
            frames: [...frames],
            fault: fault,
            out: out
        });
    }
    
    return { faults: pageFaults, finalFrames: frames, history: history };
}

function simulateLRUDetailed(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    const history = [];
    
    for (let i = 0; i < pages.length; i++) {
        const page = pages[i];
        let fault = false;
        let out = null;
        
        if (!frames.includes(page)) {
            pageFaults++;
            fault = true;
            
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lruIndex = 0;
                let minLastUsed = i;
                
                for (let j = 0; j < frames.length; j++) {
                    let lastUsed = -1;
                    for (let k = i - 1; k >= 0; k--) {
                        if (pages[k] === frames[j]) {
                            lastUsed = k;
                            break;
                        }
                    }
                    
                    if (lastUsed < minLastUsed) {
                        minLastUsed = lastUsed;
                        lruIndex = j;
                    }
                }
                
                out = frames[lruIndex];
                frames[lruIndex] = page;
            }
        }
        
        history.push({
            frames: [...frames],
            fault: fault,
            out: out
        });
    }
    
    return { faults: pageFaults, finalFrames: frames, history: history };
}

function simulateLFUDetailed(pages, frameCount) {
    const frames = [];
    const frequency = {};
    let pageFaults = 0;
    const history = [];
    
    for (let page of pages) {
        frequency[page] = (frequency[page] || 0) + 1;
        
        let fault = false;
        let out = null;
        
        if (!frames.includes(page)) {
            pageFaults++;
            fault = true;
            
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lfuIndex = 0;
                let minFreq = frequency[frames[0]];
                
                for (let j = 1; j < frames.length; j++) {
                    if (frequency[frames[j]] < minFreq) {
                        minFreq = frequency[frames[j]];
                        lfuIndex = j;
                    }
                }
                
                out = frames[lfuIndex];
                frames[lfuIndex] = page;
            }
        }
        
        history.push({
            frames: [...frames],
            fault: fault,
            out: out
        });
    }
    
    return { faults: pageFaults, finalFrames: frames, history: history };
}
// ========================== 페이지 교체 세분화 알고리즘 끝 ==========================
// ========================== 페이지 교체 알고리즘 끝 ==========================

// ========================== 스케줄링 알고리즘 시작 ==========================
function generateRandomSchedulingProblem(categoryIndex) {
    const algorithms = ['FCFS', 'SJF', 'RR'];
    const algorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
    
    const processCount = 3 + Math.floor(Math.random() * 3);
    const processes = [];
    
    for (let i = 0; i < processCount; i++) {
        processes.push({
            name: `P${i + 1}`,
            arrival: i === 0 ? 0 : Math.floor(Math.random() * 5),
            burst: 2 + Math.floor(Math.random() * 7)
        });
    }
    
    processes.sort((a, b) => a.arrival - b.arrival);
    
    let avgWaitTime = 0;
    let quantum = 0;
    
    if (algorithm === 'FCFS') {
        avgWaitTime = simulateFCFS(processes);
    } else if (algorithm === 'SJF') {
        avgWaitTime = simulateSJF(processes);
    } else if (algorithm === 'RR') {
        quantum = 2 + Math.floor(Math.random() * 2);
        avgWaitTime = simulateRR(processes, quantum);
    }
    
    let questionTable = '\n프로세스 | 도착시간 | 실행시간\n--------|---------|--------\n';
    processes.forEach(p => {
        questionTable += `${p.name}      | ${p.arrival}       | ${p.burst}\n`;
    });
    
    let questionText = `${algorithm} 스케줄링의 평균 대기시간을 계산하시오.${questionTable}`;
    
    if (algorithm === 'RR') {
        questionText = `RR(Round Robin) 스케줄링의 평균 대기시간을 계산하시오. (타임 슬라이스 = ${quantum})${questionTable}`;
    }
    
    categories[categoryIndex].problems[currentProblemIndex].question = questionText;
    categories[categoryIndex].problems[currentProblemIndex].answer = avgWaitTime.toFixed(2);
}

function simulateFCFS(processes) {
    let currentTime = 0;
    let totalWaitTime = 0;
    
    processes.forEach(p => {
        if (currentTime < p.arrival) {
            currentTime = p.arrival;
        }
        
        const waitTime = currentTime - p.arrival;
        totalWaitTime += waitTime;
        
        currentTime += p.burst;
    });
    
    return totalWaitTime / processes.length;
}

function simulateSJF(processes) {
    const remaining = [...processes];
    const completed = [];
    let currentTime = 0;
    let totalWaitTime = 0;
    
    while (remaining.length > 0) {
        const available = remaining.filter(p => p.arrival <= currentTime);
        
        if (available.length === 0) {
            currentTime = remaining[0].arrival;
            continue;
        }
        
        available.sort((a, b) => a.burst - b.burst);
        const selected = available[0];
        
        const waitTime = currentTime - selected.arrival;
        totalWaitTime += waitTime;
        
        currentTime += selected.burst;
        
        const index = remaining.indexOf(selected);
        remaining.splice(index, 1);
        completed.push(selected);
    }
    
    return totalWaitTime / processes.length;
}

function simulateRR(processes, quantum) {
    const queue = [];
    const remainingBurst = {};
    const waitTime = {};
    const arrivalTime = {};
    
    processes.forEach(p => {
        remainingBurst[p.name] = p.burst;
        waitTime[p.name] = 0;
        arrivalTime[p.name] = p.arrival;
    });
    
    let currentTime = 0;
    let index = 0;
    
    queue.push(processes[0]);
    index++;
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (currentTime < arrivalTime[current.name]) {
            currentTime = arrivalTime[current.name];
        }
        
        const executeTime = Math.min(quantum, remainingBurst[current.name]);
        
        currentTime += executeTime;
        remainingBurst[current.name] -= executeTime;
        
        while (index < processes.length && processes[index].arrival <= currentTime) {
            queue.push(processes[index]);
            index++;
        }
        
        if (remainingBurst[current.name] > 0) {
            queue.push(current);
        } else {
            waitTime[current.name] = currentTime - arrivalTime[current.name] - processes.find(p => p.name === current.name).burst;
        }
    }
    
    let totalWaitTime = 0;
    processes.forEach(p => {
        totalWaitTime += waitTime[p.name];
    });
    
    return totalWaitTime / processes.length;
}
// ========================== 스케줄링 알고리즘 끝 ==========================

// ========================== 진법 변환 알고리즘 시작 ==========================
function generateRandomBaseConversionProblem(categoryIndex) {
    const conversionTypes = [
        { from: 10, to: 2, name: '10진수 → 2진수' },
        { from: 10, to: 8, name: '10진수 → 8진수' },
        { from: 10, to: 16, name: '10진수 → 16진수' },
        { from: 2, to: 10, name: '2진수 → 10진수' },
        { from: 8, to: 10, name: '8진수 → 10진수' },
        { from: 16, to: 10, name: '16진수 → 10진수' },
        { from: 2, to: 16, name: '2진수 → 16진수' }
    ];
    
    const type = conversionTypes[Math.floor(Math.random() * conversionTypes.length)];
    
    let decimalValue, sourceValue, targetValue;
    
    if (type.from === 10) {
        decimalValue = 1 + Math.floor(Math.random() * 255);
        sourceValue = decimalValue.toString(10);
        targetValue = decimalValue.toString(type.to).toUpperCase();
    } else if (type.to === 10) {
        decimalValue = 1 + Math.floor(Math.random() * 255);
        sourceValue = decimalValue.toString(type.from).toUpperCase();
        targetValue = decimalValue.toString(10);
    } else {
        decimalValue = 1 + Math.floor(Math.random() * 255);
        sourceValue = decimalValue.toString(type.from).toUpperCase();
        targetValue = decimalValue.toString(type.to).toUpperCase();
    }
    
    const baseNames = {
        2: '2진수',
        8: '8진수',
        10: '10진수',
        16: '16진수'
    };
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `다음 ${baseNames[type.from]}를 ${baseNames[type.to]}로 변환하시오.\n\n${sourceValue}(${type.from}) = ( )(${type.to})`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = targetValue;
}
// ========================== 진법 변환 알고리즘 끝 ==========================