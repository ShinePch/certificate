// ========================== ì „ì—­ ë³€ìˆ˜ ==========================
let categories = [];
let currentCategoryIndex = null;
let currentProblemIndex = 0;
let showAnswer = false;

// ========================== ì´ˆê¸°í™” ë° ë°ì´í„° ë¡œë“œ ==========================
document.addEventListener('DOMContentLoaded', () => {
    loadData();
});

async function loadData() {
    try {
        const response = await fetch('InformationProcessing.json');
        const data = await response.json();
        
        categories = data.categories;
        
        renderAccordion();
        
    } catch (error) {
        console.error('JSON íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨:', error);
        alert('ë¬¸ì œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }
}

// ========================== ì•„ì½”ë””ì–¸ ë Œë”ë§ ==========================
function renderAccordion() {
    const container = document.getElementById('accordionContainer');
    container.innerHTML = '';
    
    categories.forEach((category, index) => {
        const accordionItem = document.createElement('div');
        accordionItem.className = 'accordion-item';
        accordionItem.id = `accordion-${index}`;
        
        const header = document.createElement('div');
        header.className = 'accordion-header';
        header.onclick = () => toggleAccordion(index);
        
        header.innerHTML = `
            <div class="accordion-title">
                <span class="accordion-icon">${category.icon}</span>
                <span>${category.name}</span>
            </div>
            <span class="accordion-arrow">â–¼</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'accordion-content';
        content.id = `content-${index}`;
        
        if (category.problems && category.problems.length > 0) {
            content.innerHTML = createProblemContent(index);
        } else {
            content.innerHTML = `
                <div class="empty-message">
                    <div class="empty-message-icon">ğŸ“</div>
                    <div class="empty-message-text">ì¤€ë¹„ ì¤‘ì¸ ì¹´í…Œê³ ë¦¬ì…ë‹ˆë‹¤</div>
                </div>
            `;
        }
        
        accordionItem.appendChild(header);
        accordionItem.appendChild(content);
        container.appendChild(accordionItem);
    });
}

function toggleAccordion(index) {
    const item = document.getElementById(`accordion-${index}`);
    const wasActive = item.classList.contains('active');
    
    document.querySelectorAll('.accordion-item').forEach(el => {
        el.classList.remove('active');
    });
    
    if (!wasActive) {
        item.classList.add('active');
        currentCategoryIndex = index;
        currentProblemIndex = 0;
        
        if (categories[index].problems && categories[index].problems.length > 0) {
            updateProblemDisplay(index);
        }
    } else {
        currentCategoryIndex = null;
    }
}

// ========================== ë¬¸ì œ í™”ë©´ êµ¬ì„± ==========================
function createProblemContent(categoryIndex) {
    return `
        <div class="problem-container" id="problem-container-${categoryIndex}">
            <div class="problem-info">
                <div class="info-left">
                    <span class="badge badge-primary" id="problemNumber-${categoryIndex}">ë¬¸ì œ 1 / ${categories[categoryIndex].problems.length}</span>
                    <span class="badge badge-secondary" id="examInfo-${categoryIndex}">ì‹œí—˜</span>
                    <span class="badge badge-category" id="categoryBadge-${categoryIndex}" style="display: none;"></span>
                </div>
                <span class="badge badge-success">${categories[categoryIndex].name}</span>
            </div>

            <div class="problem-grid" id="problemGrid-${categoryIndex}"></div>

            <div class="problem-box">
                <h3>ë¬¸ì œ</h3>
                <p id="questionText-${categoryIndex}" class="question-text"></p>
            </div>

            <div class="answer-input-box">
                <label for="userAnswer-${categoryIndex}">ë‹µì•ˆ ì…ë ¥</label>
                <textarea 
                    id="userAnswer-${categoryIndex}" 
                    placeholder="ë‹µì„ ì…ë ¥í•˜ì„¸ìš”..."
                    rows="3"
                ></textarea>
            </div>

            <div class="difficulty-selector" id="difficultySelector-${categoryIndex}" style="display: none;">
                <label for="difficulty-${categoryIndex}">ë‚œì´ë„ ì„ íƒ:</label>
                <select id="difficulty-${categoryIndex}" class="difficulty-dropdown">
                    <option value="1">ğŸ“Š ê°„ë‹¨ (ë ˆë²¨ 1)</option>
                    <option value="2">ğŸ”¥ ë³µì¡ (ë ˆë²¨ 2)</option>
                </select>
            </div>

            <!-- â¬‡ï¸â¬‡ï¸â¬‡ï¸ ì—¬ê¸°ì— ì¶”ê°€! â¬‡ï¸â¬‡ï¸â¬‡ï¸ -->
            <div class="category-selector" id="categorySelector-${categoryIndex}" style="display: none;">
                <label for="cCategory-${categoryIndex}">ë¬¸ì œ ìœ í˜• ì„ íƒ:</label>
                <select id="cCategory-${categoryIndex}" class="category-dropdown">
                    <optgroup label="ğŸ“Š ì •ë ¬ ì•Œê³ ë¦¬ì¦˜">
                        <option value="selectionSort">ì„ íƒì •ë ¬</option>
                        <option value="bubbleSort">ë²„ë¸”ì •ë ¬</option>
                        <option value="insertionSort">ì‚½ì…ì •ë ¬</option>
                    </optgroup>
                    <optgroup label="âš™ï¸ ì—°ì‚°">
                        <option value="logicalOp">ë…¼ë¦¬ì—°ì‚°</option>
                        <option value="bitOp">ë¹„íŠ¸ì—°ì‚°</option>
                    </optgroup>
                    <optgroup label="ğŸ”€ ì¡°ê±´ë¬¸">
                        <option value="ifStmt">ifë¬¸</option>
                        <option value="switchStmt">switchë¬¸</option>
                    </optgroup>
                    <optgroup label="ğŸ” ë°˜ë³µë¬¸">
                        <option value="forLoop">forë¬¸</option>
                        <option value="whileLoop">whileë¬¸</option>
                        <option value="doWhile">do-whileë¬¸</option>
                        <option value="breakContinue">break/continue</option>
                        <option value="nestedLoop">ë‹¤ì¤‘forë¬¸</option>
                    </optgroup>
                    <optgroup label="ğŸ“¦ ë°°ì—´ & í¬ì¸í„°">
                        <option value="array">ë°°ì—´</option>
                        <option value="pointer">í¬ì¸í„°</option>
                        <option value="arrayPointer">ë°°ì—´ê³¼í¬ì¸í„°</option>
                        <option value="array2d">2ì°¨ì›ë°°ì—´</option>
                        <option value="pointerArray">í¬ì¸í„°ë°°ì—´</option>
                    </optgroup>
                    <optgroup label="ğŸ—ï¸ êµ¬ì¡°ì²´">
                        <option value="struct">êµ¬ì¡°ì²´</option>
                        <option value="arrayPointerStruct">ë°°ì—´í¬ì¸í„°</option>
                    </optgroup>
                    <optgroup label="ğŸ“ í•¨ìˆ˜">
                        <option value="function">ê¸°ë³¸í•¨ìˆ˜</option>
                        <option value="functionLoop">í•¨ìˆ˜ì™€ë°˜ë³µë¬¸</option>
                        <option value="functionAddress">í•¨ìˆ˜ì—ì£¼ì†Œì „ë‹¬</option>
                        <option value="functionScope">í•¨ìˆ˜ì™€ë³€ìˆ˜ìœ íš¨ë²”ìœ„</option>
                        <option value="functionReturnAddress">í•¨ìˆ˜ê°€ì£¼ì†Œë¦¬í„´</option>
                        <option value="staticVar">staticë³€ìˆ˜</option>
                        <option value="recursion">ì¬ê·€í•¨ìˆ˜</option>
                        <option value="multiRecursion">ì¤‘ë³µì¬ê·€í•¨ìˆ˜</option>
                    </optgroup>
                    <optgroup label="ğŸ“Œ ê¸°íƒ€">
                        <option value="printfOrder">printfì¶œë ¥ìˆœì„œ</option>
                    </optgroup>
                </select>
            </div>
            <div class="algorithm-selector" id="algorithmSelector-${categoryIndex}" style="display: none;">
                <label for="pageAlgorithm-${categoryIndex}">ì•Œê³ ë¦¬ì¦˜ ì„ íƒ:</label>
                <select id="pageAlgorithm-${categoryIndex}" class="algorithm-dropdown">
                    <option value="FIFO">ğŸ“¥ FIFO (First In First Out)</option>
                    <option value="LRU">ğŸ•’ LRU (Least Recently Used)</option>
                    <option value="LFU">ğŸ“Š LFU (Least Frequently Used)</option>
                </select>
            </div>            
            <button onclick="generateRandomProblem(${categoryIndex})" class="btn btn-random">
                ğŸ² ìƒˆ ë¬¸ì œ ë§Œë“¤ê¸°
            </button>

            <button onclick="toggleAnswer(${categoryIndex})" class="btn btn-answer" id="toggleAnswerBtn-${categoryIndex}">
                ì •ë‹µ í™•ì¸
            </button>

            <div id="answerBox-${categoryIndex}" class="answer-box hidden">
                <h3>ì •ë‹µ</h3>
                <p id="answerText-${categoryIndex}" class="answer-text"></p>
            </div>

            <div class="navigation">
                <button onclick="prevProblem(${categoryIndex})" class="btn btn-nav" id="prevBtn-${categoryIndex}">ì´ì „ ë¬¸ì œ</button>
                <button onclick="nextProblem(${categoryIndex})" class="btn btn-nav btn-primary" id="nextBtn-${categoryIndex}">ë‹¤ìŒ ë¬¸ì œ</button>
            </div>
        </div>
    `;
}

// ========================== ë¬¸ì œ í‘œì‹œ ë° ë„¤ë¹„ê²Œì´ì…˜ ==========================
function updateProblemDisplay(categoryIndex) {
    const category = categories[categoryIndex];
    const problem = category.problems[currentProblemIndex];
    
    document.getElementById(`problemNumber-${categoryIndex}`).textContent = 
        `ë¬¸ì œ ${currentProblemIndex + 1} / ${category.problems.length}`;
    document.getElementById(`examInfo-${categoryIndex}`).textContent = problem.exam;
    // ì¹´í…Œê³ ë¦¬ ë±ƒì§€ ì¶”ê°€
    const categoryBadge = document.getElementById(`categoryBadge-${categoryIndex}`);
    if (categoryBadge && problem.category) {
        categoryBadge.textContent = problem.category;
        categoryBadge.style.display = 'inline-block';
    } else if (categoryBadge) {
        categoryBadge.style.display = 'none';
    }
    // ë¬¸ì œ í…ìŠ¤íŠ¸ í‘œì‹œ
    const questionElement = document.getElementById(`questionText-${categoryIndex}`);
    // \\nì„ ì‹¤ì œ ì¤„ë°”ê¿ˆìœ¼ë¡œ ë³€í™˜
    questionElement.textContent = problem.question.replace(/\\n/g, '\n');

    // Python ì½”ë“œê°€ ìˆìœ¼ë©´ ìŠ¤íƒ€ì¼ ì¶”ê°€
    if (category.id === 'python' && (problem.question.includes('def ') || problem.question.includes('print(') || problem.question.includes('for ') || problem.question.includes('='))) {
        questionElement.classList.add('has-python-code');
    }// Java ì½”ë“œê°€ ìˆìœ¼ë©´ ìŠ¤íƒ€ì¼ ì¶”ê°€
    else if (category.id === 'java' && (problem.question.includes('public class') || problem.question.includes('class ') || problem.question.includes('System.out'))) {
        questionElement.classList.add('has-java-code');
        questionElement.classList.remove('has-python-code');
        questionElement.classList.remove('has-c-code');
    } 
    // Cì–¸ì–´ ì½”ë“œê°€ ìˆìœ¼ë©´ ìŠ¤íƒ€ì¼ ì¶”ê°€
    else if (category.id === 'c' && (problem.question.includes('#include') || problem.question.includes('int main()') || problem.question.includes('printf('))) {
        questionElement.classList.add('has-c-code');
        questionElement.classList.remove('has-python-code');
        questionElement.classList.remove('has-java-code');
    }
    document.getElementById(`answerText-${categoryIndex}`).textContent = problem.answer;
    
    document.getElementById(`userAnswer-${categoryIndex}`).value = '';
    
    hideAnswerBox(categoryIndex);
    updateNavigationButtons(categoryIndex);
    createProblemGrid(categoryIndex);
    
    // ë‚œì´ë„ ì„ íƒ í‘œì‹œ/ìˆ¨ê¹€ (Pythonë§Œ í‘œì‹œ)
    const difficultySelector = document.getElementById(`difficultySelector-${categoryIndex}`);
    if (difficultySelector) {
        if (category.id === 'python') {
            difficultySelector.style.display = 'block';
        } else {
            difficultySelector.style.display = 'none';
        }
    }
    const categorySelector = document.getElementById(`categorySelector-${categoryIndex}`);
    if (categorySelector) {
        if (category.id === 'c' && currentProblemIndex === 28) {
            categorySelector.style.display = 'block';
        } else {
            categorySelector.style.display = 'none';
        }
    }
    const algorithmSelector = document.getElementById(`algorithmSelector-${categoryIndex}`);
    if (algorithmSelector) {
        if (category.id === 'page' && currentProblemIndex === 3) {
            algorithmSelector.style.display = 'block';
        } else {
            algorithmSelector.style.display = 'none';
        }
    }    
}

function createProblemGrid(categoryIndex) {
    const grid = document.getElementById(`problemGrid-${categoryIndex}`);
    const category = categories[categoryIndex];
    
    grid.innerHTML = '';
    
    category.problems.forEach((_, index) => {
        const btn = document.createElement('button');
        btn.className = 'problem-number-btn';
        if (index === currentProblemIndex) {
            btn.classList.add('active');
        }
        btn.textContent = index + 1;
        btn.onclick = () => goToProblem(categoryIndex, index);
        grid.appendChild(btn);
    });
}

function goToProblem(categoryIndex, problemIndex) {
    currentProblemIndex = problemIndex;
    updateProblemDisplay(categoryIndex);
}

function nextProblem(categoryIndex) {
    const category = categories[categoryIndex];
    if (currentProblemIndex < category.problems.length - 1) {
        currentProblemIndex++;
        updateProblemDisplay(categoryIndex);
    }
}

function prevProblem(categoryIndex) {
    if (currentProblemIndex > 0) {
        currentProblemIndex--;
        updateProblemDisplay(categoryIndex);
    }
}

function updateNavigationButtons(categoryIndex) {
    const category = categories[categoryIndex];
    document.getElementById(`prevBtn-${categoryIndex}`).disabled = currentProblemIndex === 0;
    document.getElementById(`nextBtn-${categoryIndex}`).disabled = currentProblemIndex === category.problems.length - 1;
}

// ========================== ì •ë‹µ í‘œì‹œ ==========================
function toggleAnswer(categoryIndex) {
    const answerBox = document.getElementById(`answerBox-${categoryIndex}`);
    const toggleBtn = document.getElementById(`toggleAnswerBtn-${categoryIndex}`);
    const answerText = document.getElementById(`answerText-${categoryIndex}`);
    const category = categories[categoryIndex];
    
    if (answerBox.classList.contains('hidden')) {
        // í˜ì´ì§€ êµì²´ 4ë²ˆ ë¬¸ì œë©´ HTML ë Œë”ë§
        if (category.id === 'page' && currentProblemIndex === 3) {
            answerText.innerHTML = category.problems[currentProblemIndex].answer;
        } else {
            answerText.textContent = category.problems[currentProblemIndex].answer;
        }
        
        answerBox.classList.remove('hidden');
        toggleBtn.textContent = 'ì •ë‹µ ìˆ¨ê¸°ê¸°';
    } else {
        hideAnswerBox(categoryIndex);
    }
}

function hideAnswerBox(categoryIndex) {
    const answerBox = document.getElementById(`answerBox-${categoryIndex}`);
    const toggleBtn = document.getElementById(`toggleAnswerBtn-${categoryIndex}`);
    
    answerBox.classList.add('hidden');
    toggleBtn.textContent = 'ì •ë‹µ í™•ì¸';
}

// ========================== ëœë¤ ë¬¸ì œ ìƒì„± ë©”ì¸ ==========================
function generateRandomProblem(categoryIndex) {
    const category = categories[categoryIndex];
    const problem = category.problems[currentProblemIndex];
    
    if (category.id === 'subnet') {
        if (problem.id === 1) {
            generateRandomIPAllocationProblem(categoryIndex);
        } else if (problem.id === 2) {
            generateRandomFLSMProblem(categoryIndex);
        } else if (problem.id === 3) {
            generateRandomSubnetProblem(categoryIndex);
        }
    } else if (category.id === 'page') {
        if (currentProblemIndex === 3) {  // 4ë²ˆ ë¬¸ì œ
            const algorithmSelect = document.getElementById(`pageAlgorithm-${categoryIndex}`);
            const selectedAlgorithm = algorithmSelect ? algorithmSelect.value : 'FIFO';
            generateCategorizedPageProblem(categoryIndex, selectedAlgorithm);
        } else {  // 1~3ë²ˆ ë¬¸ì œ
            generateRandomPageReplacementProblem(categoryIndex);  // ê¸°ì¡´ ë°©ì‹ ê·¸ëŒ€ë¡œ
        }
    } else if (category.id === 'schedule') {
        generateRandomSchedulingProblem(categoryIndex);
    } else if (category.id === 'base') {
        generateRandomBaseConversionProblem(categoryIndex);
    } else if (category.id === 'python') {
        // ë‚œì´ë„ ì„ íƒ ê°€ì ¸ì˜¤ê¸°
        const difficultySelect = document.getElementById(`difficulty-${categoryIndex}`);
        const difficulty = difficultySelect ? parseInt(difficultySelect.value) : 1;
        generateRandomPythonProblem(categoryIndex, difficulty);
    } else if (category.id === 'java') { 
        generateRandomJavaProblem(categoryIndex);
    } else if (category.id === 'c') {
        if (currentProblemIndex === 28) {  // 29ë²ˆ ë¬¸ì œ
            const categorySelect = document.getElementById(`cCategory-${categoryIndex}`);
            const selectedCategory = categorySelect ? categorySelect.value : 'forLoop';
            generateCategorizedCProblem(categoryIndex, selectedCategory);
        } else {  // 1~28ë²ˆ ë¬¸ì œ
            generateRandomCProblem(categoryIndex);  // ê¸°ì¡´ ë°©ì‹ ê·¸ëŒ€ë¡œ
        }
    }
    
    updateProblemDisplay(categoryIndex);
}

// ========================== ì„œë¸Œë„·/ë„¤íŠ¸ì›Œí¬ ì•Œê³ ë¦¬ì¦˜ ì‹œì‘ ==========================
function generateRandomSubnetProblem(categoryIndex) {
    const octets = [
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256)
    ];
    
    const subnetMasks = [128, 192, 224, 240, 248, 252];
    const subnetMask = subnetMasks[Math.floor(Math.random() * subnetMasks.length)];
    
    const ipAddress = `${octets[0]}.${octets[1]}.${octets[2]}.${octets[3]}`;
    const maskString = `255.255.255.${subnetMask}`;
    
    const networkAddress = octets[3] & subnetMask;
    const hostBits = 8 - Math.log2(256 - subnetMask);
    const totalHosts = Math.pow(2, hostBits) - 2;
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `IP ì£¼ì†Œê°€ ${ipAddress}ì´ê³  ì„œë¸Œë„·ë§ˆìŠ¤í¬ ${maskString}ì¼ ë•Œ ì•„ë˜ì˜ ë‹µì„ ì‘ì„±í•˜ì‹œì˜¤.\n(1) ê´„í˜¸ì•ˆì— ë“¤ì–´ê°ˆ ë„¤íŠ¸ì›Œí¬ ì£¼ì†Œ : ${octets[0]}.${octets[1]}.${octets[2]}.( )\n(2) í•´ë‹¹ ë„¤íŠ¸ì›Œí¬ ì£¼ì†Œì™€ ë¸Œë¡œë“œìºìŠ¤íŠ¸ ì£¼ì†Œë¥¼ ì œì™¸í•œ í˜¸ìŠ¤íŠ¸ ê°œìˆ˜`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = 
        `(1) ${networkAddress}\n(2) ${totalHosts}`;
}

function generateRandomFLSMProblem(categoryIndex) {
    const octets = [
        192,
        168,
        Math.floor(Math.random() * 256),
        0
    ];
    
    const cidrs = [20, 22, 24];
    const cidr = cidrs[Math.floor(Math.random() * cidrs.length)];
    
    const divisions = [2, 4, 8];
    const divisionCount = divisions[Math.floor(Math.random() * divisions.length)];
    
    const whichNetwork = Math.floor(Math.random() * divisionCount) + 1;
    
    const newCidr = cidr + Math.log2(divisionCount);
    const hostBits = 32 - newCidr;
    const subnetSize = Math.pow(2, hostBits);
    
    const networkBase = `${octets[0]}.${octets[1]}.${octets[2]}.${octets[3]}`;
    
    let broadcastIP;
    if (cidr === 24) {
        const broadcastLastOctet = (whichNetwork * subnetSize) - 1;
        broadcastIP = `${octets[0]}.${octets[1]}.${octets[2]}.${broadcastLastOctet}`;
    } else if (cidr === 22) {
        const totalBroadcast = (whichNetwork * subnetSize) - 1;
        const thirdOctet = Math.floor(totalBroadcast / 256);
        const fourthOctet = totalBroadcast % 256;
        broadcastIP = `${octets[0]}.${octets[1]}.${thirdOctet}.${fourthOctet}`;
    } else {
        const totalBroadcast = (whichNetwork * subnetSize) - 1;
        const thirdOctet = Math.floor(totalBroadcast / 256);
        const fourthOctet = totalBroadcast % 256;
        broadcastIP = `${octets[0]}.${octets[1]}.${thirdOctet}.${fourthOctet}`;
    }
    
    const networkNames = ['ì²«', 'ë‘', 'ì„¸', 'ë„¤', 'ë‹¤ì„¯', 'ì—¬ì„¯', 'ì¼ê³±', 'ì—¬ëŸ'];
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `${networkBase}/${cidr}ì¸ ë„¤íŠ¸ì›Œí¬ë¥¼ FLSM ${divisionCount}ê°œë¡œ ë¶„í• í•˜ì˜€ë‹¤. ${networkNames[whichNetwork - 1]}ë²ˆì§¸ ë„¤íŠ¸ì›Œí¬ ë¸Œë¡œë“œìºìŠ¤íŠ¸ IPë¥¼ 10ì§„ìˆ˜ë¡œ ë³€í™˜í•œ ê°’ì„ ì‘ì„±í•˜ì‹œì˜¤.`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = broadcastIP;
}

function generateRandomIPAllocationProblem(categoryIndex) {
    const baseOctet1 = 192;
    const baseOctet2 = 168;
    const baseOctet3 = Math.floor(Math.random() * 50) + 1;
    
    const ip1 = `${baseOctet1}.${baseOctet2}.${baseOctet3}.${Math.floor(Math.random() * 200) + 1}/24`;
    const ip3 = `${baseOctet1 - Math.floor(Math.random() * 60)}.${200 + Math.floor(Math.random() * 55)}.${Math.floor(Math.random() * 50)}.${Math.floor(Math.random() * 200) + 1}/22`;
    const ip6 = `${baseOctet1}.${baseOctet2}.${baseOctet3 + 1}.${Math.floor(Math.random() * 200) + 1}/24`;
    
    const choice1 = `${baseOctet1}.${baseOctet2}.${baseOctet3}.0`;
    const choice2 = `${baseOctet1}.${baseOctet2}.${baseOctet3}.${Math.floor(Math.random() * 200) + 50}`;
    const choice3 = `${baseOctet1}.${baseOctet2}.${baseOctet3 + 1}.0`;
    const choice4 = `${baseOctet1}.${baseOctet2}.${baseOctet3 + 1}.${Math.floor(Math.random() * 200) + 200}`;
    
    const ip3Parts = ip3.split('.');
    const ip3Base = `${ip3Parts[0]}.${ip3Parts[1]}.${parseInt(ip3Parts[2]) & 0xFC}.0`;
    const choice5 = ip3Base;
    const choice6 = `${ip3Parts[0]}.${ip3Parts[1]}.${(parseInt(ip3Parts[2]) & 0xFC) + 3}.${Math.floor(Math.random() * 200) + 200}`;
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `ë„¤íŠ¸ì›Œí¬ì—ì„œ ë¼ìš°í„°ë¥¼ í†µí•œ í• ë‹¹ ê°€ëŠ¥í•œ 2ë²ˆ, 4ë²ˆ, 5ë²ˆì˜ IPë¥¼ ì‘ì„±í•˜ì‹œì˜¤.\n1) ${ip1}\n3) ${ip3}\n6) ${ip6}\n\në³´ê¸°\n${choice1}, ${choice2}, ${choice3}, ${choice4}, ${choice5}, ${choice6}`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = 
        `2) ${choice2}\n4) ${choice4}\n5) ${choice6}`;
}
// ========================== ì„œë¸Œë„·/ë„¤íŠ¸ì›Œí¬ ì•Œê³ ë¦¬ì¦˜ ë ==========================

// ========================== í˜ì´ì§€ êµì²´ ì•Œê³ ë¦¬ì¦˜ ì‹œì‘ ==========================
function generateRandomPageReplacementProblem(categoryIndex) {
    const algorithms = ['FIFO', 'LRU', 'LFU'];
    const algorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
    
    const frameCount = 3 + Math.floor(Math.random() * 2);
    
    const pageCount = 12 + Math.floor(Math.random() * 9);
    const pages = [];
    for (let i = 0; i < pageCount; i++) {
        pages.push(Math.floor(Math.random() * 10));
    }
    
    const pageString = pages.join(' ');
    
    let faults = 0;
    if (algorithm === 'FIFO') {
        faults = simulateFIFO(pages, frameCount);
    } else if (algorithm === 'LRU') {
        faults = simulateLRU(pages, frameCount);
    } else if (algorithm === 'LFU') {
        faults = simulateLFU(pages, frameCount);
    }
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `${algorithm} í˜ì´ì§€ êµì²´ ì•Œê³ ë¦¬ì¦˜ì— ë”°ë¥¸ í˜ì´ì§€ ë¶€ì¬ íšŸìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤. (í”„ë ˆì„ ${frameCount}ê°œ)\n\ní˜ì´ì§€ ì°¸ì¡° ìˆœì„œ: ${pageString}`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = `${faults}`;
}

function simulateFIFO(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    
    for (let page of pages) {
        if (!frames.includes(page)) {
            pageFaults++;
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                frames.shift();
                frames.push(page);
            }
        }
    }
    
    return pageFaults;
}

function simulateLRU(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    
    for (let i = 0; i < pages.length; i++) {
        const page = pages[i];
        
        if (!frames.includes(page)) {
            pageFaults++;
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lruIndex = 0;
                let minLastUsed = i;
                
                for (let j = 0; j < frames.length; j++) {
                    let lastUsed = -1;
                    for (let k = i - 1; k >= 0; k--) {
                        if (pages[k] === frames[j]) {
                            lastUsed = k;
                            break;
                        }
                    }
                    
                    if (lastUsed < minLastUsed) {
                        minLastUsed = lastUsed;
                        lruIndex = j;
                    }
                }
                
                frames[lruIndex] = page;
            }
        }
    }
    
    return pageFaults;
}

function simulateLFU(pages, frameCount) {
    const frames = [];
    const frequency = {};
    let pageFaults = 0;
    
    for (let page of pages) {
        frequency[page] = (frequency[page] || 0) + 1;
        
        if (!frames.includes(page)) {
            pageFaults++;
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lfuIndex = 0;
                let minFreq = frequency[frames[0]];
                
                for (let j = 1; j < frames.length; j++) {
                    if (frequency[frames[j]] < minFreq) {
                        minFreq = frequency[frames[j]];
                        lfuIndex = j;
                    }
                }
                
                frames[lfuIndex] = page;
            }
        }
    }
    
    return pageFaults;
}
// ========================== í˜ì´ì§€ êµì²´ ì„¸ë¶„í™” ì•Œê³ ë¦¬ì¦˜ ì‹œì‘ ==========================
function generateCategorizedPageProblem(categoryIndex, algorithm) {
    const frameCount = 3 + Math.floor(Math.random() * 2);
    
    const pageCount = 12 + Math.floor(Math.random() * 9);
    const pages = [];
    for (let i = 0; i < pageCount; i++) {
        pages.push(Math.floor(Math.random() * 10));
    }
    
    const pageString = pages.join(' ');
    
    let result;
    
    if (algorithm === 'FIFO') {
        result = simulateFIFODetailed(pages, frameCount);
    } else if (algorithm === 'LRU') {
        result = simulateLRUDetailed(pages, frameCount);
    } else if (algorithm === 'LFU') {
        result = simulateLFUDetailed(pages, frameCount);
    }
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `${algorithm} í˜ì´ì§€ êµì²´ ì•Œê³ ë¦¬ì¦˜ì— ë”°ë¥¸ í˜ì´ì§€ ë¶€ì¬ íšŸìˆ˜ì™€ í”„ë ˆì„ ìµœì¢… ìƒíƒœë¥¼ ì‘ì„±í•˜ì‹œì˜¤. (í”„ë ˆì„ ${frameCount}ê°œ)\n\ní˜ì´ì§€ ì°¸ì¡° ìˆœì„œ: ${pageString}`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = 
        formatPageReplacementAnswer(result, pages, frameCount);
}

function formatPageReplacementAnswer(result, pages, frameCount) {
    let html = '<div class="page-algorithm-result">';
    
    // í…Œì´ë¸” ì‹œì‘
    html += '<table class="page-table">';
    
    // í—¤ë”
    html += '<thead><tr>';
    html += '<th class="label-col">êµ¬ë¶„</th>';
    for (let i = 0; i < pages.length; i++) {
        html += `<th>${i + 1}</th>`;
    }
    html += '</tr></thead>';
    
    // ë°”ë””
    html += '<tbody>';
    
    // ì°¸ì¡° í–‰
    html += '<tr class="reference-row">';
    html += '<td class="label-col">ì°¸ì¡°</td>';
    for (let page of pages) {
        html += `<td class="reference-cell">${page}</td>`;
    }
    html += '</tr>';
    
    // í”„ë ˆì„ í–‰ë“¤
    for (let f = 0; f < frameCount; f++) {
        html += `<tr class="frame-row">`;
        html += `<td class="label-col">í”„ë ˆì„${f + 1}</td>`;
        for (let step of result.history) {
            const frameValue = step.frames[f];
            if (frameValue !== undefined && frameValue !== null) {
                html += `<td class="frame-cell">${frameValue}</td>`;
            } else {
                html += `<td class="empty-cell">-</td>`;
            }
        }
        html += '</tr>';
    }
    
    // ë¶€ì¬ í–‰
    html += '<tr class="fault-row">';
    html += '<td class="label-col">ë¶€ì¬</td>';
    for (let step of result.history) {
        if (step.fault) {
            html += `<td class="fault-yes">O</td>`;
        } else {
            html += `<td class="fault-no">X</td>`;
        }
    }
    html += '</tr>';
    
    // Out í–‰
    html += '<tr class="out-row">';
    html += '<td class="label-col">Out</td>';
    for (let step of result.history) {
        if (step.out !== null && step.out !== undefined) {
            html += `<td class="out-cell">${step.out}</td>`;
        } else {
            html += `<td class="empty-cell">-</td>`;
        }
    }
    html += '</tr>';
    
    html += '</tbody>';
    html += '</table>';
    
    // ìš”ì•½
    html += '<div class="result-summary">';
    html += `<div class="summary-item"><span class="summary-label">ğŸ“Š í˜ì´ì§€ ë¶€ì¬ íšŸìˆ˜:</span> <span class="summary-value">${result.faults}</span></div>`;
    html += `<div class="summary-item"><span class="summary-label">ğŸ“¦ í”„ë ˆì„ ìµœì¢… ìƒíƒœ:</span> <span class="summary-value">[${result.finalFrames.join(', ')}]</span></div>`;
    html += '</div>';
    
    html += '</div>';
    
    return html;
}

function simulateFIFODetailed(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    const history = [];
    
    for (let page of pages) {
        let fault = false;
        let out = null;
        
        if (!frames.includes(page)) {
            pageFaults++;
            fault = true;
            
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                out = frames.shift();
                frames.push(page);
            }
        }
        
        history.push({
            frames: [...frames],
            fault: fault,
            out: out
        });
    }
    
    return { faults: pageFaults, finalFrames: frames, history: history };
}

function simulateLRUDetailed(pages, frameCount) {
    const frames = [];
    let pageFaults = 0;
    const history = [];
    
    for (let i = 0; i < pages.length; i++) {
        const page = pages[i];
        let fault = false;
        let out = null;
        
        if (!frames.includes(page)) {
            pageFaults++;
            fault = true;
            
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lruIndex = 0;
                let minLastUsed = i;
                
                for (let j = 0; j < frames.length; j++) {
                    let lastUsed = -1;
                    for (let k = i - 1; k >= 0; k--) {
                        if (pages[k] === frames[j]) {
                            lastUsed = k;
                            break;
                        }
                    }
                    
                    if (lastUsed < minLastUsed) {
                        minLastUsed = lastUsed;
                        lruIndex = j;
                    }
                }
                
                out = frames[lruIndex];
                frames[lruIndex] = page;
            }
        }
        
        history.push({
            frames: [...frames],
            fault: fault,
            out: out
        });
    }
    
    return { faults: pageFaults, finalFrames: frames, history: history };
}

function simulateLFUDetailed(pages, frameCount) {
    const frames = [];
    const frequency = {};
    let pageFaults = 0;
    const history = [];
    
    for (let page of pages) {
        frequency[page] = (frequency[page] || 0) + 1;
        
        let fault = false;
        let out = null;
        
        if (!frames.includes(page)) {
            pageFaults++;
            fault = true;
            
            if (frames.length < frameCount) {
                frames.push(page);
            } else {
                let lfuIndex = 0;
                let minFreq = frequency[frames[0]];
                
                for (let j = 1; j < frames.length; j++) {
                    if (frequency[frames[j]] < minFreq) {
                        minFreq = frequency[frames[j]];
                        lfuIndex = j;
                    }
                }
                
                out = frames[lfuIndex];
                frames[lfuIndex] = page;
            }
        }
        
        history.push({
            frames: [...frames],
            fault: fault,
            out: out
        });
    }
    
    return { faults: pageFaults, finalFrames: frames, history: history };
}
// ========================== í˜ì´ì§€ êµì²´ ì„¸ë¶„í™” ì•Œê³ ë¦¬ì¦˜ ë ==========================
// ========================== í˜ì´ì§€ êµì²´ ì•Œê³ ë¦¬ì¦˜ ë ==========================

// ========================== ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ ì‹œì‘ ==========================
function generateRandomSchedulingProblem(categoryIndex) {
    const algorithms = ['FCFS', 'SJF', 'RR'];
    const algorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
    
    const processCount = 3 + Math.floor(Math.random() * 3);
    const processes = [];
    
    for (let i = 0; i < processCount; i++) {
        processes.push({
            name: `P${i + 1}`,
            arrival: i === 0 ? 0 : Math.floor(Math.random() * 5),
            burst: 2 + Math.floor(Math.random() * 7)
        });
    }
    
    processes.sort((a, b) => a.arrival - b.arrival);
    
    let avgWaitTime = 0;
    let quantum = 0;
    
    if (algorithm === 'FCFS') {
        avgWaitTime = simulateFCFS(processes);
    } else if (algorithm === 'SJF') {
        avgWaitTime = simulateSJF(processes);
    } else if (algorithm === 'RR') {
        quantum = 2 + Math.floor(Math.random() * 2);
        avgWaitTime = simulateRR(processes, quantum);
    }
    
    let questionTable = '\ní”„ë¡œì„¸ìŠ¤ | ë„ì°©ì‹œê°„ | ì‹¤í–‰ì‹œê°„\n--------|---------|--------\n';
    processes.forEach(p => {
        questionTable += `${p.name}      | ${p.arrival}       | ${p.burst}\n`;
    });
    
    let questionText = `${algorithm} ìŠ¤ì¼€ì¤„ë§ì˜ í‰ê·  ëŒ€ê¸°ì‹œê°„ì„ ê³„ì‚°í•˜ì‹œì˜¤.${questionTable}`;
    
    if (algorithm === 'RR') {
        questionText = `RR(Round Robin) ìŠ¤ì¼€ì¤„ë§ì˜ í‰ê·  ëŒ€ê¸°ì‹œê°„ì„ ê³„ì‚°í•˜ì‹œì˜¤. (íƒ€ì„ ìŠ¬ë¼ì´ìŠ¤ = ${quantum})${questionTable}`;
    }
    
    categories[categoryIndex].problems[currentProblemIndex].question = questionText;
    categories[categoryIndex].problems[currentProblemIndex].answer = avgWaitTime.toFixed(2);
}

function simulateFCFS(processes) {
    let currentTime = 0;
    let totalWaitTime = 0;
    
    processes.forEach(p => {
        if (currentTime < p.arrival) {
            currentTime = p.arrival;
        }
        
        const waitTime = currentTime - p.arrival;
        totalWaitTime += waitTime;
        
        currentTime += p.burst;
    });
    
    return totalWaitTime / processes.length;
}

function simulateSJF(processes) {
    const remaining = [...processes];
    const completed = [];
    let currentTime = 0;
    let totalWaitTime = 0;
    
    while (remaining.length > 0) {
        const available = remaining.filter(p => p.arrival <= currentTime);
        
        if (available.length === 0) {
            currentTime = remaining[0].arrival;
            continue;
        }
        
        available.sort((a, b) => a.burst - b.burst);
        const selected = available[0];
        
        const waitTime = currentTime - selected.arrival;
        totalWaitTime += waitTime;
        
        currentTime += selected.burst;
        
        const index = remaining.indexOf(selected);
        remaining.splice(index, 1);
        completed.push(selected);
    }
    
    return totalWaitTime / processes.length;
}

function simulateRR(processes, quantum) {
    const queue = [];
    const remainingBurst = {};
    const waitTime = {};
    const arrivalTime = {};
    
    processes.forEach(p => {
        remainingBurst[p.name] = p.burst;
        waitTime[p.name] = 0;
        arrivalTime[p.name] = p.arrival;
    });
    
    let currentTime = 0;
    let index = 0;
    
    queue.push(processes[0]);
    index++;
    
    while (queue.length > 0) {
        const current = queue.shift();
        
        if (currentTime < arrivalTime[current.name]) {
            currentTime = arrivalTime[current.name];
        }
        
        const executeTime = Math.min(quantum, remainingBurst[current.name]);
        
        currentTime += executeTime;
        remainingBurst[current.name] -= executeTime;
        
        while (index < processes.length && processes[index].arrival <= currentTime) {
            queue.push(processes[index]);
            index++;
        }
        
        if (remainingBurst[current.name] > 0) {
            queue.push(current);
        } else {
            waitTime[current.name] = currentTime - arrivalTime[current.name] - processes.find(p => p.name === current.name).burst;
        }
    }
    
    let totalWaitTime = 0;
    processes.forEach(p => {
        totalWaitTime += waitTime[p.name];
    });
    
    return totalWaitTime / processes.length;
}
// ========================== ìŠ¤ì¼€ì¤„ë§ ì•Œê³ ë¦¬ì¦˜ ë ==========================

// ========================== ì§„ë²• ë³€í™˜ ì•Œê³ ë¦¬ì¦˜ ì‹œì‘ ==========================
function generateRandomBaseConversionProblem(categoryIndex) {
    const conversionTypes = [
        { from: 10, to: 2, name: '10ì§„ìˆ˜ â†’ 2ì§„ìˆ˜' },
        { from: 10, to: 8, name: '10ì§„ìˆ˜ â†’ 8ì§„ìˆ˜' },
        { from: 10, to: 16, name: '10ì§„ìˆ˜ â†’ 16ì§„ìˆ˜' },
        { from: 2, to: 10, name: '2ì§„ìˆ˜ â†’ 10ì§„ìˆ˜' },
        { from: 8, to: 10, name: '8ì§„ìˆ˜ â†’ 10ì§„ìˆ˜' },
        { from: 16, to: 10, name: '16ì§„ìˆ˜ â†’ 10ì§„ìˆ˜' },
        { from: 2, to: 16, name: '2ì§„ìˆ˜ â†’ 16ì§„ìˆ˜' }
    ];
    
    const type = conversionTypes[Math.floor(Math.random() * conversionTypes.length)];
    
    let decimalValue, sourceValue, targetValue;
    
    if (type.from === 10) {
        decimalValue = 1 + Math.floor(Math.random() * 255);
        sourceValue = decimalValue.toString(10);
        targetValue = decimalValue.toString(type.to).toUpperCase();
    } else if (type.to === 10) {
        decimalValue = 1 + Math.floor(Math.random() * 255);
        sourceValue = decimalValue.toString(type.from).toUpperCase();
        targetValue = decimalValue.toString(10);
    } else {
        decimalValue = 1 + Math.floor(Math.random() * 255);
        sourceValue = decimalValue.toString(type.from).toUpperCase();
        targetValue = decimalValue.toString(type.to).toUpperCase();
    }
    
    const baseNames = {
        2: '2ì§„ìˆ˜',
        8: '8ì§„ìˆ˜',
        10: '10ì§„ìˆ˜',
        16: '16ì§„ìˆ˜'
    };
    
    categories[categoryIndex].problems[currentProblemIndex].question = 
        `ë‹¤ìŒ ${baseNames[type.from]}ë¥¼ ${baseNames[type.to]}ë¡œ ë³€í™˜í•˜ì‹œì˜¤.\n\n${sourceValue}(${type.from}) = ( )(${type.to})`;
    
    categories[categoryIndex].problems[currentProblemIndex].answer = targetValue;
}
// ========================== ì§„ë²• ë³€í™˜ ì•Œê³ ë¦¬ì¦˜ ë ==========================